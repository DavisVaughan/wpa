# --------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See LICENSE.txt in the project root for license information.
# --------------------------------------------------------------------------------------------

#' @title Create a hierarchical clustering of selected metrics
#'
#' @description
#' Apply hierarchical clustering to selected metrics
#' The hierarchical clustering uses cosine distance and the ward.D method
#' of agglomeration.
#'
#'
#' @param data A data frame containing `PersonId` and selected metrics for clustering.
#' @param metrics Vector of metrics to use for clustering.
#' @param k Numeric vector to specify the `k` number of clusters to cut by.
#' @param return Character vector to specify what to return.
#' Valid options include "data", "table" and "hclust".
#'"hclust" returns the hierarchical model generated by the function.
#'
#'
#' @import dplyr
#' @import tidyselect
#' @import ggplot2
#' @importFrom proxy dist
#' @importFrom stats hclust
#' @importFrom stats rect.hclust
#' @importFrom stats cutree
#' @importFrom tidyr replace_na
#'
#' @examples
#' \dontrun{
#' personas_hclust(sq_data, k = 4, return = "table")
#'
#' personas_hclust(sq_data, k = 4, return = "data")
#'
#' }
#'
#'
#' @family Work Patterns
#'
#' @export
personas_hclust <- function(data,
                            metrics,
                            k = 4,
                            return = "table"){

  ## Use names for matching
  input_var <- metrics


  ## transform the data for clusters
 data_cluster <- data %>% select(PersonId, input_var)


  ## Run hclust
  h_clust <-
    data_cluster %>%
    select(input_var) %>%
    proxy::dist(method = "cosine") %>%
    stats::hclust(method = "ward.D")

  # Dendrogram
  # plot(h_clust)
  # rect.hclust(h_clust, k = 4)
  # dendro_plot <- recordPlot()


  ## Cut tree
  cuts <- stats::cutree(h_clust, k = k)

  #bind cut tree to data frame
  data_final <-
    data_cluster%>%
    select(PersonId) %>%
    cbind("cluster" = cuts) %>%
    left_join(data, by = "PersonId")


  ## Return
  if(return == "data"){

    return(data_final)

  } else if(return == "table"){

    ## Count table
    count_tb <-
      data_final %>%
      group_by(cluster) %>%
      summarise(n = n()) %>%
      mutate(prop = n / sum(n))

    ## Summary statistics
    sums_tb <-
      data_final %>%
      group_by(cluster) %>%
      summarise_if(is.numeric,function(x) round(mean(x),1))


    count_tb %>%
      left_join(sums_tb, by = "cluster") %>%
      return()

  } else if(return =="plot"){
    stop("Working on it :)")
    # data_final%>%
    #   gather( KPI, value,-cluster,-PersonId)  %>%
    #   ggplot(aes(x = value, y = KPI)) +
    #   geom_point(size = 1, alpha = 1/5)+
    #  facet_grid(vars(cluster))

      # geom_point(size = 1,
      #            alpha = 1/5,
      #            color = "#578DB8",
      #            position = position_jitter(width = 0.1, height = 0.1))+
       #ylim(-2, 5)+


  }

  else if(return == "hclust"){

    return(h_clust)

  } else {

    stop("Invalid input for `return`.")

  }
}


